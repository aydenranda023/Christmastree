<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ æŒä¸Šåœ£è¯æ ‘ (å®‰å“æ‰‹åŠ¿ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: sans-serif;
            touch-action: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 30%, #000000 150%);
        }

        /* å¯åŠ¨æŒ‰é’® (æ‰‹æœºå¿…é¡»æ‰‹åŠ¨ç‚¹å‡»æ‰èƒ½æ’­æ”¾å£°éŸ³/å¯åŠ¨æ‘„åƒå¤´) */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            background: #d40000;
            border: none;
            border-radius: 50px;
            margin-top: 20px;
        }

        .header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .header h1 {
            margin: 0;
            font-weight: 300;
            font-size: 24px;
            letter-spacing: 2px;
        }

        .header p {
            opacity: 0.8;
            font-size: 12px;
            margin-top: 5px;
            color: #aaccff;
        }

        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #555;
            border-radius: 50%;
        }

        .dot.active {
            background: #44ff44;
            box-shadow: 0 0 5px #44ff44;
        }

        .dot.pinch {
            background: #ffff44;
            box-shadow: 0 0 5px #ffff44;
        }

        .status-text {
            color: white;
            font-size: 10px;
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª— (è°ƒè¯•ç”¨ï¼Œå®é™…å¯éšè—) */
        .input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 8px;
            /* 3:4 æ¯”ä¾‹ */
            opacity: 0.5;
            z-index: 20;
            transform: scaleX(-1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            object-fit: cover;
        }

        #photo-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 80%;
            max-width: 300px;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.4);
            display: none;
            pointer-events: auto;
            z-index: 100;
            text-align: center;
            transition: 0.3s;
            opacity: 0;
        }

        #photo-modal.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        /* å…œåº•æ»‘å— */
        .manual-control {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            pointer-events: auto;
            text-align: center;
        }

        input[type=range] {
            width: 100%;
        }

        .hint-text {
            color: #888;
            font-size: 10px;
            margin-bottom: 5px;
            display: block;
        }
    </style>
</head>

<body>

    <div id="start-screen">
        <h1 style="color:white; font-weight:300;">æ‰‹æœºç«¯ AR ä½“éªŒ</h1>
        <p style="color:#aaa; font-size:12px; margin-top:10px;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ â€¢ ä¿æŒå…‰çº¿å……è¶³</p>
        <button id="start-btn">ç‚¹å‡»å¼€å§‹</button>
    </div>

    <audio id="bgm" loop>
        <source
            src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_c5053df2f2.mp3?filename=christmas-magic-12555.mp3"
            type="audio/mpeg">
    </audio>

    <div id="ui-layer">
        <div class="header">
            <h1>MERRY XMAS</h1>
            <p>åŒæ‰‹å¼ å¼€ç‚¸æ ‘ | æåˆæ‰‹æŒ‡çœ‹ç…§ç‰‡</p>
        </div>
        <div class="status-panel">
            <div class="status-indicator">
                <div class="dot" id="hand-dot"></div>
                <div class="status-text" id="hand-status">ç­‰å¾…...</div>
            </div>
            <div class="status-indicator">
                <div class="dot" id="pinch-dot"></div>
                <div class="status-text">æåˆ</div>
            </div>
        </div>
        <div class="manual-control">
            <span class="hint-text">å¦‚æœæ‘„åƒå¤´æ²¡ååº”ï¼Œè¯·æ‹–åŠ¨æ»‘å—ï¼š</span>
            <input type="range" id="expansion-slider" min="0" max="100" value="0">
        </div>
    </div>

    <video class="input_video" playsinline autoplay muted></video>
    <div id="canvas-container"></div>

    <div id="photo-modal">
        <div id="modal-content"></div>
        <div style="margin-top:15px; color:#333;" onclick="closeModal()">å…³é—­</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"
        crossorigin="anonymous"></script>

    <script>
        // --- 0. å¯åŠ¨ä¸æƒé™ ---
        let isStarted = false;
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('bgm').play().catch(e => { });
            document.getElementById('hand-status').innerText = "å¯åŠ¨ç›¸æœº...";
            initCamera(); // å¿…é¡»ç”±ç”¨æˆ·ç‚¹å‡»è§¦å‘
            isStarted = true;
        });

        // --- 1. åŸºç¡€ ---
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(0.4, 'rgba(200,240,255,0.4)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(c);
        }

        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.005);
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 22); camera.lookAt(0, 3, 0); // æ‰‹æœºç«¯æ‹‰è¿œè·ç¦»

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // æ€§èƒ½ä¼˜åŒ–
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        let handDistance = 0, manualValue = 0, smoothExpansion = 0;
        let isPinching = false, isModalOpen = false, lastPinchTime = 0;

        // --- 2. ç²’å­æ ‘ (ç²¾ç®€ç‰ˆ) ---
        const treeGeometry = new THREE.BufferGeometry();
        const positions = [], colors = [], randomness = [], sizes = [], types = [];
        const treeHeight = 18, treeRadius = 8;

        // å‡å°‘ç²’å­æ•°ä»¥é€‚åº”æ‰‹æœº (æ€»æ•°çº¦ 15000)
        // A. æ ‘å¶
        for (let i = 0; i < 12000; i++) {
            const t = i / 12000, ang = t * Math.PI * 2 * 30, r = Math.pow(1 - t, 1.3) * treeRadius + Math.random();
            const x = Math.cos(ang) * r, y = t * treeHeight - treeHeight / 2, z = Math.sin(ang) * r;
            positions.push(x, y, z);
            randomness.push((Math.random() - 0.5) * 20, 10 + Math.random() * 20, (Math.random() - 0.5) * 20);
            colors.push(0.1, 0.8, 0.3); sizes.push(0.5 + Math.random()); types.push(0.0);
        }
        // B. å½©ç¯ (ä¼šç‚¸)
        for (let i = 0; i < 1500; i++) {
            const t = Math.random(), ang = Math.random() * 6.28, r = Math.pow(1 - t, 1.3) * treeRadius + 0.6;
            positions.push(Math.cos(ang) * r, t * treeHeight - treeHeight / 2, Math.sin(ang) * r);
            randomness.push((Math.random() - 0.5) * 20, 10 + Math.random() * 20, (Math.random() - 0.5) * 20);
            const c = new THREE.Color(); c.setHSL(Math.random(), 1.0, 0.6);
            colors.push(c.r, c.g, c.b); sizes.push(2.0); types.push(1.0);
        }
        // C. æ ‘é¡¶ (é™æ­¢)
        for (let i = 0; i < 300; i++) {
            const r = Math.random(), th = Math.random() * 6.28, ph = Math.acos(2 * Math.random() - 1);
            positions.push(r * Math.sin(ph) * Math.cos(th), treeHeight / 2 + 1 + r * Math.sin(ph) * Math.sin(th), r * Math.cos(ph));
            randomness.push(0, 0, 0); colors.push(1, 1, 0.5); sizes.push(4.0); types.push(2.0);
        }

        treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        treeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        treeGeometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randomness, 3));
        treeGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        treeGeometry.setAttribute('aType', new THREE.Float32BufferAttribute(types, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uExpansion: { value: 0 }, uTexture: { value: createGlowTexture() } },
            vertexShader: `
                uniform float uTime; uniform float uExpansion;
                attribute vec3 aRandom; attribute vec3 color; attribute float aSize; attribute float aType;
                varying vec3 vColor; varying float vType;
                void main() {
                    vColor=color; vType=aType;
                    float effExp = uExpansion;
                    if(aType > 1.5) effExp = 0.0; 
                    vec3 finalPos = mix(position, position + aRandom, effExp);
                    if(uExpansion < 0.1) {
                        float ang = uTime*0.1;
                        float c=cos(ang); float s=sin(ang);
                        vec3 rot = finalPos; rot.x=finalPos.x*c+finalPos.z*s; rot.z=finalPos.x*-s+finalPos.z*c;
                        finalPos = rot;
                    }
                    vec4 mv = modelViewMatrix * vec4(finalPos, 1.0);
                    float blink = 0.8 + 0.4*sin(uTime*3.0 + position.x);
                    float scale = (aType>1.5)?40.0:25.0;
                    gl_PointSize = (aSize * scale * blink) * (1.0 / -mv.z);
                    gl_Position = projectionMatrix * mv;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture; varying vec3 vColor;
                void main() {
                    vec4 tex = texture2D(uTexture, gl_PointCoord); if(tex.a<0.1) discard;
                    gl_FragColor = vec4(vColor*1.5, tex.a);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        scene.add(new THREE.Points(treeGeometry, particleMaterial));

        // --- 3. ç…§ç‰‡ ---
        const photosGroup = new THREE.Group(); scene.add(photosGroup);
        const pColors = ["#FF3333", "#00EE55", "#3388FF", "#FFAA00", "#AA33FF"];
        const photoSprites = [];
        for (let i = 0; i < 5; i++) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 150;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, 128, 150);
            ctx.fillStyle = pColors[i]; ctx.fillRect(10, 10, 108, 108);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            const a = Math.random() * 6.28, r = 4, y = Math.random() * 6;
            sprite.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
            sprite.userData = { origPos: sprite.position.clone(), explodeTarget: sprite.position.clone().multiplyScalar(4), color: pColors[i] };
            sprite.scale.set(3, 3.6, 1);
            photosGroup.add(sprite); photoSprites.push(sprite);
        }

        // --- 4. å…³é”®ï¼šMediaPipe æ‰‹æœºé€‚é… ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const handDot = document.getElementById('hand-dot');
        const handStatus = document.getElementById('hand-status');
        const pinchDot = document.getElementById('pinch-dot');

        document.getElementById('expansion-slider').addEventListener('input', (e) => {
            manualValue = parseInt(e.target.value) / 100;
        });

        function onResults(results) {
            isPinching = false;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length >= 1) {
                handDot.className = "dot active"; handStatus.innerText = "å·²è¯†åˆ«";

                // æ‰‹æœºå•æ‰‹æ“ä½œä¼˜åŒ–ï¼šå¦‚æœåªæ£€æµ‹åˆ°ä¸€åªæ‰‹ï¼Œæˆ‘ä»¬å°è¯•ç”¨è¿™åªæ‰‹çš„æ‹‡æŒ‡å’Œå°æŒ‡è·ç¦»æ¥æ§åˆ¶å¼€åˆ
                // æˆ–è€…å¦‚æœæœ‰ä¸¤åªæ‰‹ï¼Œè¿˜æ˜¯ç”¨ä¸¤æ‰‹è·ç¦»
                let val = 0;
                if (results.multiHandLandmarks.length === 2) {
                    // åŒæ‰‹æ¨¡å¼
                    const h1 = results.multiHandLandmarks[0][9];
                    const h2 = results.multiHandLandmarks[1][9];
                    val = (Math.abs(h1.x - h2.x) - 0.1) * 3.0;
                } else {
                    // å•æ‰‹æ¨¡å¼ï¼šçœ‹æ‹‡æŒ‡å’Œå°æŒ‡çš„è·ç¦» (ç²—ç•¥æ¨¡æ‹Ÿå¼ å¼€æ‰‹æŒ)
                    const thumb = results.multiHandLandmarks[0][4];
                    const pinky = results.multiHandLandmarks[0][20];
                    val = (Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2)) - 0.1) * 4.0;
                }
                handDistance = Math.max(0, Math.min(1, val));

                // æåˆæ£€æµ‹
                for (const landmarks of results.multiHandLandmarks) {
                    const t = landmarks[4]; const i = landmarks[8];
                    if (Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)) < 0.05) { isPinching = true; break; }
                }
            } else {
                handDot.className = "dot"; handDistance = 0;
            }
            pinchDot.className = isPinching ? "dot pinch" : "dot";
        }

        function initCamera() {
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); // æ‰‹æœºç«¯ç”¨ complexity 0
            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 480, height: 640, // æ‰‹æœºç«–å±åˆ†è¾¨ç‡
                facingMode: 'user' // å¼ºåˆ¶å‰ç½®æ‘„åƒå¤´
            });
            camera.start().catch(e => {
                handStatus.innerText = "æ‘„åƒå¤´å¤±è´¥";
                console.error(e);
            });
        }

        function showModal(color) {
            isModalOpen = true;
            const modal = document.getElementById('photo-modal');
            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('show'), 10);
            document.getElementById('modal-content').innerHTML = `<div style="width:100%; height:200px; background:${color};"></div>`;
        }
        window.closeModal = function () {
            const m = document.getElementById('photo-modal');
            m.classList.remove('show'); setTimeout(() => { m.style.display = 'none'; isModalOpen = false; }, 300);
        }

        // --- 5. å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            const target = Math.max(handDistance, manualValue);
            smoothExpansion += (target - smoothExpansion) * 0.1;

            if (smoothExpansion > 0.8 && isPinching && !isModalOpen) {
                if (time - lastPinchTime > 1.5) { showModal(pColors[0]); lastPinchTime = time; }
            }

            particleMaterial.uniforms.uTime.value = time;
            particleMaterial.uniforms.uExpansion.value = smoothExpansion;

            photoSprites.forEach(s => {
                const start = s.userData.origPos, end = s.userData.explodeTarget;
                if (smoothExpansion < 0.1) s.scale.set(0, 0, 0);
                else {
                    s.position.lerpVectors(start, end, smoothExpansion);
                    s.scale.set(3, 3.6, 1);
                }
            });

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight) });
        animate();
    </script>
</body>

</html>