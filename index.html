<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ æŒä¸Šåœ£è¯æ ‘ (å®‰å“æ‰‹åŠ¿ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: sans-serif;
            touch-action: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 30%, #000000 150%);
        }

        /* å¯åŠ¨æŒ‰é’® (æ‰‹æœºå¿…é¡»æ‰‹åŠ¨ç‚¹å‡»æ‰èƒ½æ’­æ”¾å£°éŸ³/å¯åŠ¨æ‘„åƒå¤´) */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            background: #d40000;
            border: none;
            border-radius: 50px;
            margin-top: 20px;
        }

        .header {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .header h1 {
            margin: 0;
            font-weight: 300;
            font-size: 24px;
            letter-spacing: 2px;
        }

        .header p {
            opacity: 0.8;
            font-size: 12px;
            margin-top: 5px;
            color: #aaccff;
        }

        .status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #555;
            border-radius: 50%;
        }

        .dot.active {
            background: #44ff44;
            box-shadow: 0 0 5px #44ff44;
        }

        .dot.pinch {
            background: #ffff44;
            box-shadow: 0 0 5px #ffff44;
        }

        .status-text {
            color: white;
            font-size: 10px;
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª— (è°ƒè¯•ç”¨ï¼Œå®é™…å¯éšè—) */
        .input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 133px;
            border-radius: 8px;
            /* 3:4 æ¯”ä¾‹ */
            opacity: 0.5;
            z-index: 20;
            transform: scaleX(-1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            object-fit: cover;
        }

        #photo-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 80%;
            max-width: 300px;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.4);
            display: none;
            pointer-events: auto;
            z-index: 100;
            text-align: center;
            transition: 0.3s;
            opacity: 0;
        }

        #photo-modal.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        /* éšè—æ‰‹åŠ¨æ»‘å— */
        .manual-control {
            display: none;
        }
    </style>
</head>

<body>

    <div id="start-screen">
        <h1 style="color:white; font-weight:300;">æ‰‹æœºç«¯ AR ä½“éªŒ</h1>
        <p style="color:#aaa; font-size:12px; margin-top:10px;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ â€¢ ä¿æŒå…‰çº¿å……è¶³</p>
        <button id="start-btn">ç‚¹å‡»å¼€å§‹</button>
    </div>

    <audio id="bgm" loop>
        <source
            src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_c5053df2f2.mp3?filename=christmas-magic-12555.mp3"
            type="audio/mpeg">
    </audio>

    <div id="ui-layer">
        <div class="header">
            <h1>MERRY XMAS</h1>
            <p>å¼ å¼€æ‰‹æŒç‚¸å¼€åœ£è¯æ ‘ | ç§»åŠ¨æ—‹è½¬ | æ‚¬åœçœ‹ç…§ç‰‡ | æåˆè¿˜åŸ</p>
        </div>
        <div class="status-panel">
            <div class="status-indicator">
                <div class="dot" id="hand-dot"></div>
                <div class="status-text" id="hand-status">ç­‰å¾…...</div>
            </div>
            <div class="status-indicator">
                <div class="dot" id="pinch-dot"></div>
                <div class="status-text">æåˆ</div>
            </div>
        </div>
        <div class="manual-control">
            <span class="hint-text">å¦‚æœæ‘„åƒå¤´æ²¡ååº”ï¼Œè¯·æ‹–åŠ¨æ»‘å—ï¼š</span>
            <input type="range" id="expansion-slider" min="0" max="100" value="0">
        </div>
    </div>

    <video class="input_video" playsinline autoplay muted></video>
    <div id="canvas-container"></div>

    <div id="photo-modal">
        <div id="modal-content"></div>
        <div style="margin-top:15px; color:#333;" onclick="closeModal()">å…³é—­</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"
        crossorigin="anonymous"></script>

    <script>
        // --- 0. å¯åŠ¨ä¸æƒé™ ---
        let isStarted = false;
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('bgm').play().catch(e => { });
            document.getElementById('hand-status').innerText = "å¯åŠ¨ç›¸æœº...";
            initCamera(); // å¿…é¡»ç”±ç”¨æˆ·ç‚¹å‡»è§¦å‘
            isStarted = true;
        });

        // --- 1. åŸºç¡€ ---
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(0.4, 'rgba(200,240,255,0.4)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64); return new THREE.CanvasTexture(c);
        }

        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.005);
        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 22); camera.lookAt(0, 3, 0); // æ‰‹æœºç«¯æ‹‰è¿œè·ç¦»

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // æ€§èƒ½ä¼˜åŒ–
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        let handDistance = 0, manualValue = 0, smoothExpansion = 0;
        let isPinching = false, isModalOpen = false, lastPinchTime = 0;

        // --- 2. ç²’å­æ ‘ (å¢å¼ºç‰ˆ) ---
        const treeGeometry = new THREE.BufferGeometry();
        const positions = [], colors = [], randomness = [], sizes = [], types = [];
        const treeHeight = 18, treeRadius = 8;

        // A. æ ‘å¶ (15000)
        for (let i = 0; i < 15000; i++) {
            const t = i / 15000, ang = t * Math.PI * 2 * 40, r = Math.pow(1 - t, 1.3) * treeRadius + Math.random();
            const x = Math.cos(ang) * r, y = t * treeHeight - treeHeight / 2, z = Math.sin(ang) * r;
            positions.push(x, y, z);
            randomness.push((Math.random() - 0.5) * 20, 10 + Math.random() * 20, (Math.random() - 0.5) * 20);
            colors.push(0.2, 1.0, 0.4); sizes.push(0.5 + Math.random()); types.push(0.0);
        }
        // B. å½©ç¯ (2000)
        for (let i = 0; i < 2000; i++) {
            const t = Math.random(), ang = Math.random() * 6.28, r = Math.pow(1 - t, 1.3) * treeRadius + 0.6;
            positions.push(Math.cos(ang) * r, t * treeHeight - treeHeight / 2, Math.sin(ang) * r);
            randomness.push((Math.random() - 0.5) * 20, 10 + Math.random() * 20, (Math.random() - 0.5) * 20);
            const c = new THREE.Color(); c.setHSL(Math.random(), 1.0, 0.7);
            colors.push(c.r, c.g, c.b); sizes.push(2.5); types.push(1.0);
        }
        // C. æ ‘é¡¶ (300)
        for (let i = 0; i < 300; i++) {
            const r = Math.random(), th = Math.random() * 6.28, ph = Math.acos(2 * Math.random() - 1);
            positions.push(r * Math.sin(ph) * Math.cos(th), treeHeight / 2 + 1 + r * Math.sin(ph) * Math.sin(th), r * Math.cos(ph));
            randomness.push(0, 0, 0); colors.push(1, 1, 0.5); sizes.push(4.0); types.push(2.0);
        }
        // D. æ˜Ÿæ˜Ÿ (1000)
        for (let i = 0; i < 1000; i++) {
            const r = 15 + Math.random() * 20, th = Math.random() * 6.28, ph = Math.acos(2 * Math.random() - 1);
            positions.push(r * Math.sin(ph) * Math.cos(th), r * Math.sin(ph) * Math.sin(th), r * Math.cos(ph));
            randomness.push(0, 0, 0); colors.push(1, 1, 1); sizes.push(2.0); types.push(3.0);
        }

        treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        treeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        treeGeometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randomness, 3));
        treeGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        treeGeometry.setAttribute('aType', new THREE.Float32BufferAttribute(types, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uExpansion: { value: 0 }, uTexture: { value: createGlowTexture() } },
            vertexShader: `
                uniform float uTime; uniform float uExpansion;
                attribute vec3 aRandom; attribute vec3 color; attribute float aSize; attribute float aType;
                varying vec3 vColor; varying float vType;
                void main() {
                    vColor=color; vType=aType;
                    float effExp = uExpansion;
                    if(aType > 1.5) effExp = 0.0; 
                    vec3 finalPos = mix(position, position + aRandom, effExp);
                    if(uExpansion < 0.1) {
                        float ang = uTime*0.1;
                        float c=cos(ang); float s=sin(ang);
                        vec3 rot = finalPos; rot.x=finalPos.x*c+finalPos.z*s; rot.z=finalPos.x*-s+finalPos.z*c;
                        finalPos = rot;
                    }
                    vec4 mv = modelViewMatrix * vec4(finalPos, 1.0);
                    
                    // é—ªçƒé€»è¾‘
                    float blink = 1.0;
                    if (aType > 2.5) { // æ˜Ÿæ˜Ÿ
                        blink = 0.5 + 0.5 * sin(uTime * 5.0 + position.x * 10.0);
                    } else if (aType > 0.5) { // å½©ç¯
                        blink = 0.8 + 0.4 * sin(uTime * 3.0 + position.x);
                    }
                    
                    float scale = (aType>1.5)?40.0:25.0;
                    if (aType > 2.5) scale = 30.0; // æ˜Ÿæ˜Ÿå¤§å°
                    
                    gl_PointSize = (aSize * scale * blink) * (1.0 / -mv.z);
                    gl_Position = projectionMatrix * mv;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture; varying vec3 vColor;
                void main() {
                    vec4 tex = texture2D(uTexture, gl_PointCoord); if(tex.a<0.1) discard;
                    gl_FragColor = vec4(vColor*1.5, tex.a);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        scene.add(new THREE.Points(treeGeometry, particleMaterial));

        // --- 3. ç…§ç‰‡ ---
        const photosGroup = new THREE.Group(); scene.add(photosGroup);
        const photoFiles = [
            "å¾®ä¿¡å›¾ç‰‡_20251225165331_86_280.jpg",
            "å¾®ä¿¡å›¾ç‰‡_20251225165332_87_280.jpg",
            "å¾®ä¿¡å›¾ç‰‡_20251225165334_89_280.jpg",
            "å¾®ä¿¡å›¾ç‰‡_20251225165335_90_280.jpg",
            "å¾®ä¿¡å›¾ç‰‡_20251225165336_91_280.jpg",
            "å¾®ä¿¡å›¾ç‰‡_20251225165337_92_280.jpg"
        ];
        const photoSprites = [];
        const textureLoader = new THREE.TextureLoader();
        const pColors = ["#FF3333", "#00EE55", "#3388FF", "#FFAA00", "#AA33FF", "#FF00FF"];

        photoFiles.forEach((file, i) => {
            // å…ˆåˆ›å»ºå¸¦é¢œè‰²çš„å ä½ç¬¦ï¼Œç¡®ä¿å³ä½¿å›¾ç‰‡åŠ è½½å¤±è´¥ä¹Ÿèƒ½çœ‹åˆ°ä¸œè¥¿
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 150;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, 128, 150);
            ctx.fillStyle = pColors[i % pColors.length]; ctx.fillRect(10, 10, 108, 108);

            const material = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) });
            const sprite = new THREE.Sprite(material);

            // éšæœºåˆ†å¸ƒ
            const a = (i / photoFiles.length) * Math.PI * 2;
            const r = 2;
            const y = (Math.random() - 0.5) * 10;
            sprite.position.set(Math.cos(a) * r, y, Math.sin(a) * r);

            sprite.userData = {
                origPos: sprite.position.clone(),
                explodeTarget: new THREE.Vector3(Math.cos(a) * 12, y * 1.5, Math.sin(a) * 12),
                isZoomed: false
            };
            sprite.scale.set(0, 0, 0); // åˆå§‹éšè—
            photosGroup.add(sprite);
            photoSprites.push(sprite);

            // å°è¯•åŠ è½½å›¾ç‰‡
            textureLoader.load(encodeURIComponent(file), (tex) => {
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
            }, undefined, (err) => {
                console.warn("Photo load failed:", file);
                // å¤±è´¥æ—¶ä¿æŒå ä½ç¬¦
            });
        });

        // --- 4. å…³é”®ï¼šMediaPipe æ‰‹æœºé€‚é… ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const handDot = document.getElementById('hand-dot');
        const handStatus = document.getElementById('hand-status');
        const pinchDot = document.getElementById('pinch-dot');

        let lastHandPos = null;
        let handVelocity = 0;
        let noMoveTime = 0;

        function onResults(results) {
            isPinching = false;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length >= 1) {
                handDot.className = "dot active"; handStatus.innerText = "å·²è¯†åˆ«";

                // æ‰‹æœºå•æ‰‹æ“ä½œä¼˜åŒ–ï¼šå¦‚æœåªæ£€æµ‹åˆ°ä¸€åªæ‰‹ï¼Œæˆ‘ä»¬å°è¯•ç”¨è¿™åªæ‰‹çš„æ‹‡æŒ‡å’Œå°æŒ‡è·ç¦»æ¥æ§åˆ¶å¼€åˆ
                // æˆ–è€…å¦‚æœæœ‰ä¸¤åªæ‰‹ï¼Œè¿˜æ˜¯ç”¨ä¸¤æ‰‹è·ç¦»
                let val = 0;
                if (results.multiHandLandmarks.length === 2) {
                    // åŒæ‰‹æ¨¡å¼
                    const h1 = results.multiHandLandmarks[0][9];
                    const h2 = results.multiHandLandmarks[1][9];
                    val = (Math.abs(h1.x - h2.x) - 0.1) * 3.0;
                } else {
                    // å•æ‰‹æ¨¡å¼ï¼šçœ‹æ‹‡æŒ‡å’Œå°æŒ‡çš„è·ç¦» (ç²—ç•¥æ¨¡æ‹Ÿå¼ å¼€æ‰‹æŒ)
                    const thumb = results.multiHandLandmarks[0][4];
                    const pinky = results.multiHandLandmarks[0][20];
                    val = (Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2)) - 0.1) * 4.0;
                }
                handDistance = Math.max(0, Math.min(1, val));

                // æåˆæ£€æµ‹ -> è§¦å‘è¿˜åŸ
                for (const landmarks of results.multiHandLandmarks) {
                    const t = landmarks[4]; const i = landmarks[8];
                    if (Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)) < 0.05) {
                        isPinching = true;
                        handDistance = 0; // æåˆå¼ºåˆ¶è¿˜åŸ
                        break;
                    }
                }

                // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨é€Ÿåº¦ (å–ç¬¬ä¸€åªæ‰‹çš„ 9 å·ç‚¹)
                const currentHandPos = results.multiHandLandmarks[0][9];
                if (lastHandPos) {
                    const dx = currentHandPos.x - lastHandPos.x;
                    const dy = currentHandPos.y - lastHandPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    handVelocity = dist;

                    // æ—‹è½¬é€»è¾‘ï¼šå¦‚æœç‚¸å¼€ä¸”åœ¨ç§»åŠ¨
                    if (smoothExpansion > 0.8 && dist > 0.005) {
                        scene.rotation.y += dx * 5.0; // æ ¹æ®æ°´å¹³ç§»åŠ¨æ—‹è½¬
                        noMoveTime = 0;
                    } else {
                        noMoveTime += 0.016; // å‡è®¾çº¦ 60fps
                    }
                }
                lastHandPos = currentHandPos;

            } else {
                handDot.className = "dot"; handDistance = 0;
                handVelocity = 0;
            }
            pinchDot.className = isPinching ? "dot pinch" : "dot";
        }

        function initCamera() {
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); // æ‰‹æœºç«¯ç”¨ complexity 0
            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 480, height: 640, // æ‰‹æœºç«–å±åˆ†è¾¨ç‡
                facingMode: 'user' // å¼ºåˆ¶å‰ç½®æ‘„åƒå¤´
            });
            camera.start().catch(e => {
                handStatus.innerText = "æ‘„åƒå¤´å¤±è´¥";
                console.error(e);
            });
        }

        function showModal(color) {
            isModalOpen = true;
            const modal = document.getElementById('photo-modal');
            modal.style.display = 'block';
            setTimeout(() => modal.classList.add('show'), 10);
            document.getElementById('modal-content').innerHTML = `<div style="width:100%; height:200px; background:${color};"></div>`;
        }
        window.closeModal = function () {
            const m = document.getElementById('photo-modal');
            m.classList.remove('show'); setTimeout(() => { m.style.display = 'none'; isModalOpen = false; }, 300);
        }

        // --- 5. å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            const target = Math.max(handDistance, manualValue);
            smoothExpansion += (target - smoothExpansion) * 0.1;

            // çŠ¶æ€æœºé€»è¾‘
            if (smoothExpansion > 0.5) {
                // ç‚¸å¼€çŠ¶æ€
                if (handVelocity < 0.002 && noMoveTime > 0.5) {
                    // åœæ­¢ç§»åŠ¨ -> æ”¾å¤§æœ€è¿‘çš„ç…§ç‰‡
                    let closestDist = 999;
                    let closestSprite = null;

                    photoSprites.forEach(s => {
                        // è®¡ç®—åˆ°ç›¸æœºçš„è·ç¦»
                        const dist = s.position.distanceTo(camera.position);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestSprite = s;
                        }
                        // å¤ä½å…¶ä»–
                        if (s !== closestSprite) {
                            s.scale.lerp(new THREE.Vector3(4, 5, 1), 0.1);
                            s.position.lerp(s.userData.explodeTarget, 0.1);
                        }
                    });

                    if (closestSprite) {
                        // ç§»å‘ç›¸æœºå‰æ–¹ä¸€ç‚¹çš„ä½ç½®
                        const targetPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5));
                        closestSprite.position.lerp(targetPos, 0.1);
                        closestSprite.scale.lerp(new THREE.Vector3(8, 10, 1), 0.1);
                        closestSprite.lookAt(camera.position);
                    }
                } else {
                    // æ­£åœ¨ç§»åŠ¨ -> æ¢å¤åŸä½
                    photoSprites.forEach(s => {
                        s.position.lerp(s.userData.explodeTarget, 0.1);
                        s.scale.lerp(new THREE.Vector3(4, 5, 1), 0.1);
                        s.lookAt(camera.position);
                    });
                }
            } else {
                // æ”¶ç¼©çŠ¶æ€
                photoSprites.forEach(s => {
                    s.position.lerp(s.userData.origPos, 0.1);
                    s.scale.set(0, 0, 0);
                });
                scene.rotation.y += 0.001; // è‡ªåŠ¨æ…¢é€Ÿæ—‹è½¬
            }

            particleMaterial.uniforms.uTime.value = time;
            particleMaterial.uniforms.uExpansion.value = smoothExpansion;

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight) });
        animate();
    </script>
</body>

</html>